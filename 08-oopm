// OOPM programs
#include <iostream>
using namespace std;

class It{
    private:
        int a, b;   //data member
    
    public:
        void setValue() {   //member function-1
            cout << "Enter the values of A and B: ";
            cin >> a >> b;
        }
        void getValue() {   //member function-2
            cout << "A = " << a << endl;
            cout << "B = " << b << endl;
        }
};

class Addition{
    private:
        int a,b;

    public:
        void setValue() {
            cout << "Enter the values of A and B: ";
            cin >> a >> b;
        }
        void getValue() {
            cout << "Entered values are: " << endl;
            cout << "A = " << a << endl;
            cout << "B = " << b << endl;
        }
        void addValue() {
            cout << "Addition of A and B = " << a+b << endl;
        }
};

int globalVar = 100;    //global varialble

class ScopeRes{
    public:
        void localFun() {
            cout << "Inside the Local Function." << endl;
        }
        void globalFun();
        
};

void ScopeRes::globalFun() {
    cout << "Inside the Global Function." << endl;
}

class Car{
    public:
        Car() {
            cout << "Inside constructor." << endl;
        }
        ~Car() {
            cout << "Inside destructor." << endl;
        }
};

class A{
    int a;
    float b;
    public:
    A() {
        cout << "Enter the value of A: ";
        cin >> a;
        cout << "Enter the float value of B: ";
        cin >> b;
        cout << "Default constructor values: " << endl;
        cout << "A = " << a << endl << "B = " << b << endl;
    }
    A(int x, int y) {
        a = x;
        b = y;
        cout << "Parameterized constructor values: " << endl;
        cout << "A = " << a << endl << "B = " << b << endl;
    }
};

class Base{
    protected:
        int a, b;
    public:
        void setValue() {
            cout << "Enter the values of A and B: ";
            cin >> a >> b;
        }
        // void getValue() {
        //     cout << "parent class values are: " << endl;
        //     cout << "A = " << a << endl;
        //     cout << "B = " << b << endl;
        // }
};

class Derived : public Base {
    private:
        float x, y;
    public:
        void setValue2() {
            cout << "Enter the float values of X and Y: ";
            cin >> x >> y;
        }
        void getValue2() {
            cout << "Entered values are: " << endl;
            cout << "X = " << x << endl;
            cout << "Y = " << y << endl;
            
            cout << "Derived values of parent class are: " << endl;
            cout << "A = " << a << endl;
            cout << "B = " << b << endl;
            
        }
};

class Animal {
    protected:
        int a,b;
    public:
        void setValue() {
            cout << "Enter the values of A and B: ";
            cin >> a >> b;
        }
};

class Cat : public Animal {
    protected:
        int m,n;
    public:
        void setValue2() {
            cout << "Enter the values of M and N: ";
            cin >> m >> n;
        }
};

class Kitten : public Cat {
    protected:
        int x,y;
    public:
        void setValue3() {
            cout << "Enter the values of X and Y: ";
            cin >> x >> y;
        }
        void display() {
            cout << "X = " << x << " " << "Y = " << y << endl;
        }
        void showValue() {
            cout << "Derived values are: " << endl;
            cout << "A = " << a << " " << "B = " << b << endl;
            cout << "M = " << m << " " << "N = " << n << endl;
        }
};

class Father {
    protected:
        string name = "Abbu!";
    public:
        void sayName() {
            cout << name << endl;
        }
};

class Mother {
    protected:
        string name2 = "Ammi!";
    public:
        void sayName() {
            cout << name2 << endl;
        }
};

class Child : public Father, public Mother {
    public:
        void msg() {
            cout << "child said...!" << endl;
        }
};

class Vehicle {
    protected:
        int a;
    public:
        void setValue() {
            cout << "Enter the value of A: ";
            cin >> a;
        }
};

class Scooty : public Vehicle {
    protected:
        int b;
    public:
        void setValue1() {
            cout << "Enter the value of B: ";
            cin >> b;
        }
        void display1() {
            cout << "Sum of A and B = " << a + b << endl;
        }
};

class Bike : public Vehicle {
    protected:
        int c;
    public:
        void setValue2() {
            cout << "Enter the value of C: ";
            cin >> c;
        }
        void display2() {
            cout << "Sum of A and C = " << a + c << endl;
        }
};

class Technology {
    public:
        void display() {
            cout << "Congrats! You have accessed Technology through coding..." << endl;
        }
};

class Laptop : virtual public Technology {
    public:
        void show1() {
            cout << "This is class -> Laptop" << endl;
        }
};

class Computer : virtual public Technology {
    public:
        void show2() {
            cout << "This is class -> Computer" << endl;
        }
};

class Coding : public Laptop, public Computer {
    public:
        void show3() {
            cout << "This is class -> Coding" << endl;
        }
};

class Dost {
    private:
        int a;
    public:
        void setValue() {
            cout << "Enter the value of A: ";
            cin >> a;
        }
        void showValue() {
            cout << "Entered Value = " << a << endl;
        }
        
        // declaration of friend function
        friend void addValue(Dost &refrenceVariable);
};

// definition of friend function
void addValue(Dost &refrenceVariable) {
    int b;
    cout << "Enter the value to add through friend function: ";
    cin >> b;
    refrenceVariable.a = refrenceVariable.a + b;
}

class Sample{
    // operator overloading function:
    // op overloading doen't meaning that ki kisi operator ki functioning ko bdalna (+ operator values ko plus hi krega minus nhi, functioning nhi bdlegi), it just meaning that to invoke the particular operator(as per our choise) with the help of an object...
    
    int x,y;
    public: 
        void get(int a, int b) {
            x = a;
            y = b;
        }
        
        void display() {
            cout << "A = " << x << endl;
            cout << "B = " << y << endl;
        }
        
        void operator ++() {  // `Sample operator ++()` ye bhi likh skte...
            x = x + 1;
            y = y + 1;
        }
};

class Chappu{
    int x;
    public:
        void get(int c) {
            x = c;
        }
        
        void display() {
            cout << x << endl;
        }
        
        friend Chappu operator *(Chappu, Chappu); // (Chappu, Chappu) specifies that the operator* function takes two parameters, both of type Chappu class...
};

Chappu operator *(Chappu obj1, Chappu obj2){    // here, Chappu is the return type of the function `operator *()` and obj1 and obj2 are objects of type Chappu.
    Chappu obj3;  
    obj3.x = obj1.x * obj2.x;
    return obj3;  // obj3 ek obj hai, koi integer nhi jo `int` return type se return ho jai, is liye apn n class (Chappu) ko hi ek return type bna diya take uska object return krva ske...
}

class Complex{
    // binary op overloading
    int x,y;
    public:
        Complex() { // default constructor
        x = 0;
        y = 0;
    }
    
    Complex(int a, int b) { // parameterised constructor
        x = a;
        y = b;
    }
    
    Complex operator +(Complex c) { // yaha pr c -> obj2 hai...
        Complex obj3;
        obj3.x = x + c.x;
        obj3.y = y + c.y;
        
        cout << "x or y ka chakkar" << endl;
        cout << "x = " << x << endl;
        cout << "y = " << y << endl;
        cout << "c.x = " << c.x << endl;
        cout << "c.y = " << c.y << endl;
        return obj3;
    }
    
    void display() {
        cout << "Sum of Real values = " << x << endl;
        cout << "Sum of Imaginary values = " << y << endl;
    }
    
};


// function overloading prog
// sirf argument/parameter different hona...
float add(int a, int b, float c) {
    return (a + b + c);
}

int add(int a, int b) {
    return (a + b);
}

// function overriding
// run time poly hai ye, isme sb kuch same hona (arg/para bhi...)
class baseClass {
    public:
// agr virtual lga diya to pointer isko call nhi kr skta...
//      virtual void fun() { 
        void fun() {
            cout << "Inside Base class" << endl;
        }
};

class derivedClass: public baseClass {
    public: 
        void fun() {
            cout << "Inside Derived class" << endl;
        }
};

// Row and Column major order demonstration of array...
void rowMajor(int arr[][4], int n, int m) {
    for(int i=0; i<n; i++) {
        for(int j=0; j<m; j++) {
            cout << arr[i][j] << " ";
        }
    }
    cout << endl;
}

void colMajor(int arr[][4], int n, int m) {
    for(int i=0; i<m; i++) {
        for(int j=0; j<n; j++) {
            cout << arr[j][i] << " ";
        }
    }
    cout << endl;
}


int main() {
    // programs listing:
    cout << "Class and object programs: " << endl;
    cout << "Enter 1 to demontrate class and objects." << endl;
    cout << "Enter 2 to add two numbers using member functions of a class." << endl;
    cout << "Enter 3 to demonstrate the use of scope resolution operator." << endl << endl;
    
    cout << "Constructor and destructor programs: " << endl;
    cout << "Enter 4 to display the concept of constructor & destructor." << endl;
    cout << "Enter 5 for Constructor overloading." << endl << endl;
    
    cout << "Inheritance programs: " << endl;
    cout << "Enter 6 to demonstrate the single inheritance." << endl;
    cout << "Enter 7 to demonstrate the multilevel inheritance." << endl;
    cout << "Enter 8 to demonstrate the multiple inheritance." << endl;
    cout << "Enter 9  to demonstrate the hierarchical inheritance." << endl;
    cout << "Enter 10 to demonstrate the hybrid inheritance." << endl << endl;
    
    cout << "Friend programs:" << endl;
    cout << "Enter 11 to demonstrate the use of friend function." << endl;
    cout << "Enter 12 to demonstrate the use of operator overloading using friend function." << endl << endl;
    
    cout << "Polymorphism programs:" << endl;
    cout << "Enter 13 to demonstrate the use of unary operator overloading." << endl;
    cout << "Enter 14 to demonstrate the use of binary operator overloading" << endl;
    cout << "Enter 15 to demonstrate the use of function overloading." << endl;
    cout << "Enter 16 WAP to demonstrate the use of function overriding." << endl;
    cout << "Enter 17 to demonstrate the use of virtual functions." << endl;
    
    cout << endl;
    int prog;
    cout << "Enter the program number: ";
    cin >> prog;
    switch(prog) {
        case 1: {
            It obj;
            obj.setValue();
            obj.getValue();
            break;
        }
            
        case 2: {
            Addition obj2;
            obj2.setValue();
            obj2.getValue();
            obj2.addValue();
            break;
        }
            
        case 3: {
            ScopeRes obj3;
            int localVar = 10;
            // localVar = 10;
            cout << "Local Variable = " << localVar << endl;
            cout << "Global Variable = " << ::globalVar << endl;
            obj3.localFun();
            obj3.globalFun();
            break;
        }
            
        case 4: {
            Car obj4;
            break;
        }
    
        case 5: {
            A obj5; 
            A obj6(50,100);
            cout << "Constructor overloaded." << endl;
            // or simply,
            // A obj5, obj6(5,10);
            break;
        } 
        case 6: {
            Base obj;  // no need 
            Derived obj2;
        
            cout << "Inside Base Class" << endl;
            // obj.setValue();  it will give garbage value in Derived class...
            obj2.setValue();    //calling Base class function with Derived class object...
            cout << "Inside Derived Class" << endl;
            obj2.setValue2();
            obj2.getValue2();
            break;
        }
        case 7: {
            // Animal obj;
            // Cat obj2;
            Kitten obj3;
            
            obj3.setValue();
            obj3.setValue2();
            obj3.setValue3();
            obj3.display();
            obj3.showValue();
            break;
        }
        case 8: {
            Child obj3;
            
            // obj3.sayName(); -> this will give ambiguity
            obj3.Father::sayName();
            obj3.Mother::sayName();
            obj3.msg(); 
            break;
        }
        case 9: {
            Vehicle obj;
            Scooty obj1;
            Bike obj2;
            
            // obj.setValue();
            obj1.setValue();
            obj1.setValue1();
            obj1.display1();
            
            obj2.setValue();
            obj2.setValue2();
            obj2.display2();
            break;
        }
        case 10: {
            // Technology ob1;
            // Laptop obj2;
            // Computer obj3;
            Coding obj4;
            
            // ...normal approach...
            // obj4.display();
            
            // ***pointerISH approach***
            Technology *p;  
            p = &obj4;
            p -> display();
            break;
        }
        case 11: {
            Dost obj;
            
            obj.setValue();
            obj.showValue();
            addValue(obj);
            obj.showValue();
            break;
        }
        case 12: {
            Chappu obj1, obj2, obj3;
            
            int a,b;
            cout << "Enter the value of A: ";
            cin >> a;
            cout << "Enter the value of B: ";
            cin >> b;
            
            obj1.get(a);
            obj2.get(b);
            cout << "After overloading: " << endl;
            obj3 = obj1 * obj2; // background working kuch is trah hori -> obj3 = obj1.operator *(obj2)...
            obj3.display();
            break;
        }
        
        case 13: {
            Sample obj;
            
            int a,b;
            cout << "Enter the value of A: ";
            cin >> a;
            cout << "Enter the value of B: ";
            cin >> b;
            
            obj.get(a,b);
            cout << "Before overloading: " << endl;
            obj.display();
            cout << "After oveloading: " << endl;
            ++obj;  // obj.operator++() ki jgah sirf ++obj, which is showing that object 'obj' is invoking the operator '++'...
            obj.display();
            break;
        }
        
        case 14: {
            Complex obj1, obj2, obj3;
            obj1 = Complex(1,5);
            obj2 = Complex(2,4);
            obj1.display();
            obj2.display();
            obj3 = obj1 + obj2; // obj3 = obj1.operator+(obj2);
            // obj1 is invoking the operator and obj2 is passed as argument...(in the line no 326)
            obj3.display();
            break;
        }
        
        case 15: {
            cout << "Addition = " << add(5,2) << endl;
            cout << "Addition = " << add(5,2,2.1) << endl;
            break;
        }
        
        case 16: {
            derivedClass obj;
            // obj.baseClass::fun();
            obj.fun();
            
            // pointer approach
            // agr virtual lga diya to pointer base class k fun() ko call nhi kr skta... (see line 362)
            baseClass *p;
            p = &obj;
            p -> fun();
            break;
        }
        
        case 18: {
            int n = 3; //row size 
            int m = 4; //col size 

            int arr[][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
    
            cout << "Given array:" << endl;
            for(int i=0; i<n; i++) {
                for(int j=0; j<m; j++) {
                    cout << arr[i][j] << " ";
                }
                cout << endl;
                }
            cout << endl;
                
            cout << "Row major order:" << endl;
            rowMajor(arr, n, m);
            cout << "Col major order:" << endl;
            colMajor(arr, n, m);
            
            break;
        }
    }
    return 0;
}
