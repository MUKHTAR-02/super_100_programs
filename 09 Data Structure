// Data Structure programs
#include <iostream>
using namespace std;

// Row and Column major order demonstration of array...
/* In C++, when you pass a 2D array to a function, you need tospecify the size of the second dimension (the number of columns) except for the first dimension (the number of rows). This is because the compiler needs to know the size of the columns to correctly calculate memory offsets when accessing elements.
    eg - arr[][4];
*/

void rowMajor(int arr[][4], int n, int m) {
    for(int i=0; i<n; i++) {
        for(int j=0; j<m; j++) {
            cout << arr[i][j] << " ";
        }
    }
    cout << endl;
}

void colMajor(int arr[][4], int n, int m) {
    for(int i=0; i<m; i++) {
        for(int j=0; j<n; j++) {
            cout << arr[j][i] << " ";
        }
    }
    cout << endl;
}

// Stack Implementation
class Stack {
    
    public: 
    int top = -1;
        void push(int arr[], int n, int a) {
            if(top < n-1) {
                top++;  
                arr[top] = a;
            } else {
                cout << "Stack Overflow!" << endl;
            }
        }
        
        void pop(int arr[], int n) {
            if(top > -1) {
                top = top - 1;
            } else {
                cout << "Stack Underflow!" << endl;
            }
        }
        
        void peek(int arr[], int n) {
            if(top > -1) {
                cout << "Top element = " << arr[top] << endl;
            } else {
                cout << "Stack Underflow!" << endl;
            }
        }
        
        void size(int arr[], int n) {
            if(top > -1) {
                cout << "Size of stack = " << top << endl;
            } else {
                cout << "Stack is empty!" << endl;
            }
        }
        
        void isEmpty(int arr[], int n) {
            if(top <= -1) {
                cout << "true" << endl;
            } else {
                cout << "false" << endl;
            }
        }
};

// Queue implementation
class Queue{
    public:
        int front = -1;
        int rear = -1;
        int backup = 0;
        
        void push(int arr[], int n, int a) {
            if(rear < n-1) {
                rear++;
                arr[rear] = a;
            } else {
                cout << "Queue overflow!" << endl;
            }
        }
        
        void pop(int arr[], int n) {
            if((front < n-1) && (front != rear)) {
                front++;
                cout << "Alwida = " << arr[front] << endl;
                backup = arr[front];
                arr[front] = -1;
            } else if(front == rear) {
                rear = -1;
                front = -1;
                cout << "Queue underflow!" << endl;
            } else {
                cout << "Queue underflow!" << endl;
            }
        }
        
        void size(int arr[], int n) {
            if(rear > -1) {
                cout << "Size of Queue = " << rear+1 << endl;
            } else {
                cout << "Queue is empty!" << endl;
            }
        }
        
        void isEmpty(int arr[], int n) {
            if(front == rear) {
                cout << "True" << endl;
            } else {
                cout << "False" << endl;
            }
        }
        
        void getRear(int arr[], int n) {
            cout << "Rear element = " << arr[rear] << endl;
            cout << "Rear index = " << rear << endl;
        }
        
        void getFront(int arr[], int n) {
            cout << "Recently removed element = " << backup << endl;
            cout << "Front index = " << front << endl;
        }
};

// Linked-list implementation
class Node{
    public:
        int data;
        Node* next; // Node is dataType of pointer next
        
    // constructor
    Node(int data) {
        this -> data = data;
        this -> next = NULL;
    }
};


int main() {
    // programs listing:
    cout << "Data Structure programs: " << endl;
    cout << "Enter 1 to demonstrate the array using row major order and column major order." << endl;
    cout << "Enter 2 to demonstrate the use of Stack." << endl;
    cout << "Enter 3 to demonstrate the use of Queue." << endl;
    cout << "Enter 4 to to demonstrate the use of Linked List." << endl;
    
    cout << endl;
    int prog;
    cout << "Enter the program number: ";
    cin >> prog;
    switch(prog) {
        case 1: {
            int n = 3; //row size 
            int m = 4; //col size 

            int arr[][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
    
            cout << "Given array:" << endl;
            for(int i=0; i<n; i++) {
                for(int j=0; j<m; j++) {
                    cout << arr[i][j] << " ";
                }
                cout << endl;
                }
            cout << endl;
                
            cout << "Row major order:" << endl;
            rowMajor(arr, n, m);
            cout << "Col major order:" << endl;
            colMajor(arr, n, m);
            
            break;
        }
        
        case 2: {
            int n = 5;
            int arr[n];
            
            Stack s;
            s.push(arr, n, 5);
            s.push(arr, n, 10);
            s.push(arr, n, 12);
            s.push(arr, n, 50);
            s.push(arr, n, 1);
            
            s.push(arr, n, 2);
            // stack overflow;
            
            s.peek(arr, n);
            // 1
            
            s.size(arr, n);
            // 4
            
            s.pop(arr, n);
            
            s.size(arr, n);
            // 3
            
            s.pop(arr, n);
            
            s.peek(arr, n);
            // 12
            
            s.pop(arr, n);
            s.pop(arr, n);
            s.pop(arr, n);
            
            s.pop(arr, n);
            // stack underflow;
            
            s.size(arr, n);
            // stack underflow
            
            s.isEmpty(arr, n);
            
            // cout << "loop hole 2 = " << arr[3] << endl;
            // still memory is not free...
            
            break;
        }
        
        case 3: {
            Queue q;
            int n = 5;
            int arr[n];
            
            q.pop(arr, n);
            // queue underflow
            
            q.push(arr, n, 1);
            q.push(arr, n, 2);
            q.push(arr, n, 3);
            q.push(arr, n, 4);
            q.push(arr, n, 5);
            q.push(arr, n, 6);
            // queue overflow
            
            q.size(arr, n);
            // 5
            
            q.pop(arr, n);
            q.pop(arr, n);
            q.pop(arr, n);
            
            q.getRear(arr, n);
            q.getFront(arr, n);
            
            q.pop(arr, n);
            q.pop(arr, n);
            
            q.isEmpty(arr, n);
            break;
        }
        
        case 4: {
            Node* node1 = new Node(5); // dynamic memory allocation... 
            // here, new Node() allocates memory for a Node class object/node object.
            // node1 is a pointer that now holds the memory address of the dynamically allocated Node class object/ node object.
            
            Node* node2 = new Node(4);
            Node* node3 = new Node(7);
            Node* node4 = new Node(2);
            Node* node5 = new Node(9);
            
            node1 -> next = node2;
            node2 -> next = node3;
            node3 -> next = node4;
            node4 -> next = node5;
            node5 -> next = NULL;
            
            cout << "Data of node1 = ";
            cout << node1 -> data << endl;
            cout << "Next address of node1 = ";
            cout << node1 -> next << endl;
            
            cout << "Data of node2 = ";
            cout << node2 -> data << endl;
            cout << "Next address of node2 = ";
            cout << node2 -> next << endl;
            
            cout << "Data of node3 = ";
            cout << node3 -> data << endl;
            cout << "Next address of node3 = ";
            cout << node3 -> next << endl;
            
            cout << "Data of node4 = ";
            cout << node4 -> data << endl;
            cout << "Next address of node4 = ";
            cout << node4 -> next << endl;
            
            cout << "Data of node5 = ";
            cout << node5 -> data << endl;
            cout << "Next address of node5 = ";
            cout << node5 -> next << endl;
            break;
        }
    }
    return 0;
}
